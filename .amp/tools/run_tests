#!/usr/bin/env bun
import fs from "node:fs";
import { spawnSync } from "node:child_process";

/**
 * This program implements the Amp Toolbox protocol to provide
 * custom tools to an LLM without writing an MCP server.
 *
 * Amp invokes this program once at startup with TOOLBOX_ACTION set
 * to "describe".  The program then needs to write its tool schema
 * to stdout.
 *
 * When the model wants to use the tool, TOOLBOX_ACTION is set to
 * "execute" and tool parameters are passed to stdin as a JSON object.
 *
 * Any output on stdout/stderr goes directly to the model and need not
 * be structured.
 */
const action = process.env.TOOLBOX_ACTION;

if (action === "describe") showDescription();
else if (action === "execute") execute();

/**
 * Use args for a simplified tool description:
 *  - [type, description]
 *  - where type is "string", "number", "object", "array", "boolean"
 *
 * Use inputSchema instead for full JSON schema support.
 */
function showDescription() {
  // The description MUST mention when to use this tool instead of Bash,
  // otherwise the model will prefer unstructured command line tools.
  //
  // Tools like this one should always have highest priority, because
  // they are carefully crafted for a specific purpose.
  process.stdout.write(
    JSON.stringify({
      name: "run_tests",
      description:
        "Use this tool (NEVER use Bash or just commands directly) to run tests. Supports running backend tests (pytest), e2e tests (Playwright), or all tests together. Optional parameters allow filtering to specific test files or patterns.",
      args: {
        action: [
          "string",
          'the action to take, one of: "all" (backend + e2e), "backend" (pytest), "e2e" (Playwright)',
        ],
        path: [
          "string",
          "optional: specific test file path to run (relative to project root)",
        ],
        pattern: [
          "string",
          "optional: test name pattern to filter (backend: pytest -k pattern, e2e: --grep pattern)",
        ],
      },
    })
  );
}

function execute() {
  // parse parameters as JSON from stdin (matches inputSchema/args from showDescription)
  let params = {};
  try {
    const input = fs.readFileSync(0, "utf-8").trim();
    params = input ? JSON.parse(input) : {};
  } catch (e) {
    console.error("Failed to parse parameters:", e.message);
    process.exit(1);
  }

  const action =
    params.action && params.action.length > 0 ? params.action : "all";
  const path = params.path;
  const pattern = params.pattern;

  // output goes directly to the model
  switch (action) {
    case "backend":
      runBackendTests(path, pattern);
      break;
    case "e2e":
      runE2ETests(path, pattern);
      break;
    case "all":
      console.log("Running all tests (backend + e2e)...\n");
      runBackendTests(path, pattern);
      console.log("\n" + "=".repeat(60) + "\n");
      runE2ETests(path, pattern);
      break;
    case "help":
      console.log("Available actions: all, backend, e2e");
      console.log(
        "Optional parameters: path (test file), pattern (test name filter)"
      );
      break;
    default:
      process.stderr.write(
        `Unknown action: ${action}\nAvailable: all, backend, e2e`
      );
      process.exit(1);
  }
}

function runBackendTests(path, pattern) {
  console.log("→ Running backend tests (pytest)...");

  const args = ["run", "--active", "pytest"];

  if (path) {
    // Normalize path: if repo-root-relative, strip backend/ prefix
    const normalizedPath = path.startsWith("backend/") 
      ? path.slice(8) 
      : path;
    args.push(normalizedPath);
  }

  if (pattern) {
    args.push("-k", pattern);
  }

  const result = spawnSync("/usr/local/bin/uv", args, {
    cwd: "backend",
    stdio: "inherit",
  });

  if (result.error) {
    console.error(`Failed to run backend tests: ${result.error.message}`);
    process.exit(1);
  }

  if (result.status !== 0) {
    console.error(`Backend tests failed with exit code ${result.status}`);
    process.exit(result.status || 1);
  }
  
  console.log("✓ Backend tests passed");
}

function runE2ETests(path, pattern) {
  console.log("→ Running E2E tests (Playwright)...");

  const args = ["playwright", "test"];

  if (path) {
    // Normalize path: if repo-root-relative, strip frontend/ prefix
    const normalizedPath = path.startsWith("frontend/") 
      ? path.slice(9) 
      : path;
    args.push(normalizedPath);
  }

  if (pattern) {
    args.push("--grep", pattern);
  }

  const result = spawnSync("/usr/bin/npx", args, {
    cwd: "frontend",
    stdio: "inherit",
  });

  if (result.error) {
    console.error(`Failed to run E2E tests: ${result.error.message}`);
    process.exit(1);
  }

  if (result.status !== 0) {
    console.error(`E2E tests failed with exit code ${result.status}`);
    process.exit(result.status || 1);
  }
  
  console.log("✓ E2E tests passed");
}
